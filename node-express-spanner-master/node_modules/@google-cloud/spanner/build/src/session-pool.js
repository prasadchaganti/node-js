"use strict";
/*!
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const is = require("is");
const p_queue_1 = require("p-queue");
const trace = require("stack-trace");
const DEFAULTS = {
    acquireTimeout: Infinity,
    concurrency: Infinity,
    fail: false,
    idlesAfter: 10,
    keepAlive: 30,
    labels: {},
    max: 100,
    maxIdle: 1,
    min: 0,
    writes: 0,
};
/**
 * Error to be thrown when attempting to release unknown resources.
 *
 * @private
 */
class ReleaseError extends Error {
    constructor(resource) {
        super('Unable to release unknown resource.');
        this.resource = resource;
    }
}
exports.ReleaseError = ReleaseError;
/**
 * Error to be thrown when session leaks are detected.
 *
 * @private
 */
class SessionLeakError extends Error {
    constructor(leaks) {
        super(`${leaks.length} session leak(s) detected.`);
        this.messages = leaks;
    }
}
exports.SessionLeakError = SessionLeakError;
/**
 * Class used to manage connections to Spanner.
 *
 * **You don't need to use this class directly, connections will be handled for
 * you.**
 *
 * @class
 * @extends {EventEmitter}
 */
class SessionPool extends events_1.EventEmitter {
    /**
     * Formats stack trace objects into Node-like stack trace.
     *
     * @param {object[]} trace The trace object.
     * @return {string}
     */
    static formatTrace(frames) {
        const stack = frames.map(frame => {
            const name = frame.getFunctionName() || frame.getMethodName();
            const file = frame.getFileName();
            const lineno = frame.getLineNumber();
            const columnno = frame.getColumnNumber();
            return `    at ${name} (${file}:${lineno}:${columnno})`;
        });
        return `Session leak detected!\n${stack.join('\n')}`;
    }
    /**
     * Total number of available sessions.
     * @type {number}
     */
    get available() {
        const reads = this._inventory["readonly" /* ReadOnly */];
        const writes = this._inventory["readwrite" /* ReadWrite */];
        return reads.length + writes.length;
    }
    /**
     * Total number of borrowed sessions.
     * @type {number}
     */
    get borrowed() {
        return this._inventory.borrowed.size;
    }
    /**
     * Flag to determine if Pool is full.
     * @type {boolean}
     */
    get isFull() {
        return this.size >= this.options.max;
    }
    /**
     * Total number of read sessions.
     * @type {number}
     */
    get reads() {
        const available = this._inventory["readonly" /* ReadOnly */].length;
        const borrowed = [...this._inventory.borrowed]
            .filter(session => session.type === "readonly" /* ReadOnly */)
            .length;
        return available + borrowed;
    }
    /**
     * Total size of pool.
     * @type {number}
     */
    get size() {
        return this.available + this.borrowed;
    }
    /**
     * Total number of write sessions.
     * @type {number}
     */
    get writes() {
        const available = this._inventory["readwrite" /* ReadWrite */].length;
        const borrowed = [...this._inventory.borrowed]
            .filter(session => session.type === "readwrite" /* ReadWrite */)
            .length;
        return available + borrowed;
    }
    /**
     * @constructor
     * @param {Database} database The DB instance.
     * @param {SessionPoolOptions} [options] Configuration options.
     */
    constructor(database, options) {
        super();
        this.isOpen = false;
        this.database = database;
        this.options = Object.assign({}, DEFAULTS, options);
        const { writes } = this.options;
        if (writes < 0 || writes > 1) {
            throw new TypeError('Write percentage should be represented as a float between 0.0 and 1.0.');
        }
        this._inventory = {
            ["readonly" /* ReadOnly */]: [],
            ["readwrite" /* ReadWrite */]: [],
            borrowed: new Set(),
        };
        this._requests = new p_queue_1.default({
            concurrency: this.options.concurrency,
        });
        this._acquires = new p_queue_1.default({
            concurrency: 1,
        });
        this._traces = new Map();
    }
    /**
     * Closes and the pool.
     *
     * @emits SessionPool#close
     * @param {SessionPoolCloseCallback} callback The callback function.
     */
    close(callback) {
        const sessions = [
            ...this._inventory["readonly" /* ReadOnly */], ...this._inventory["readwrite" /* ReadWrite */],
            ...this._inventory.borrowed
        ];
        this.isOpen = false;
        this._stopHouseKeeping();
        this.emit('close');
        sessions.forEach(session => this._destroy(session));
        this._requests.onIdle().then(() => {
            const leaks = this._getLeaks();
            let error;
            this._inventory["readonly" /* ReadOnly */] = [];
            this._inventory["readwrite" /* ReadWrite */] = [];
            this._inventory.borrowed.clear();
            if (leaks.length) {
                error = new SessionLeakError(leaks);
            }
            callback(error);
        });
    }
    /**
     * Retrieve a read session.
     *
     * @param {GetReadSessionCallback} callback The callback function.
     */
    getReadSession(callback) {
        this._acquire("readonly" /* ReadOnly */)
            .then(session => callback(null, session), callback);
    }
    /**
     * Retrieve a read/write session.
     *
     * @param {GetWriteSessionCallback} callback The callback function.
     */
    getWriteSession(callback) {
        this._acquire("readwrite" /* ReadWrite */)
            .then(session => callback(null, session, session.txn), callback);
    }
    /**
     * Opens the pool, filling it to the configured number of read and write
     * sessions.
     *
     * @emits SessionPool#open
     * @return {Promise}
     */
    open() {
        this._onClose = new Promise(resolve => this.once('close', resolve));
        this._startHouseKeeping();
        this.isOpen = true;
        this.emit('open');
        this._fill();
    }
    /**
     * Releases session back into the pool. If the session is a write session it
     * will also prepare a new transaction before releasing it.
     *
     * @throws {Error} For unknown sessions.
     * @emits SessionPool#available
     * @emits SessionPool#error
     * @param {Session} session The session to release.
     */
    release(session) {
        if (!this._inventory.borrowed.has(session)) {
            throw new ReleaseError(session);
        }
        delete session.txn;
        session.lastUsed = Date.now();
        if (session.type === "readonly" /* ReadOnly */) {
            this._release(session);
            return;
        }
        this._prepareTransaction(session)
            .catch(() => (session.type = "readonly" /* ReadOnly */))
            .then(() => this._release(session));
    }
    /**
     * Attempts to borrow a session from the pool.
     *
     * @private
     *
     * @param {string} type The desired type to borrow.
     * @returns {Promise<Session>}
     */
    _acquire(type) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isOpen) {
                throw new Error("Database is closed." /* Closed */);
            }
            const startTime = Date.now();
            const timeout = this.options.acquireTimeout;
            // wrapping this logic in a function to call recursively if the session
            // we end up with is already dead
            const getSession = () => __awaiter(this, void 0, void 0, function* () {
                const elapsed = Date.now() - startTime;
                if (elapsed >= timeout) {
                    throw new Error("Timeout occurred while acquiring session." /* Timeout */);
                }
                const session = yield this._getSession(type, startTime);
                if (this._isValidSession(session)) {
                    return session;
                }
                this._inventory.borrowed.delete(session);
                return getSession();
            });
            const session = yield this._acquires.add(getSession);
            if (type === "readwrite" /* ReadWrite */ && session.type === "readonly" /* ReadOnly */) {
                try {
                    yield this._prepareTransaction(session);
                }
                catch (e) {
                    this._release(session);
                    throw e;
                }
            }
            this._traces.set(session.id, trace.get());
            return session;
        });
    }
    /**
     * Moves a session into the borrowed group.
     *
     * @private
     *
     * @param {Session} session The session object.
     */
    _borrow(session) {
        const type = session.type;
        const index = this._inventory[type].indexOf(session);
        this._inventory.borrowed.add(session);
        this._inventory[type].splice(index, 1);
    }
    /**
     * Borrows session from specific group.
     *
     * @private
     *
     * @param {string} type The desired session type.
     * @return {Session}
     */
    _borrowFrom(type) {
        const session = this._inventory[type][0];
        this._borrow(session);
        return session;
    }
    /**
     * Grabs the next available session.
     *
     * @private
     *
     * @param {string} type The desired session type.
     * @returns {Promise<Session>}
     */
    _borrowNextAvailableSession(type) {
        const hasReads = !!this._inventory["readonly" /* ReadOnly */].length;
        if (type === "readonly" /* ReadOnly */ && hasReads) {
            return this._borrowFrom("readonly" /* ReadOnly */);
        }
        const hasWrites = !!this._inventory["readwrite" /* ReadWrite */].length;
        if (hasWrites) {
            return this._borrowFrom("readwrite" /* ReadWrite */);
        }
        return this._borrowFrom("readonly" /* ReadOnly */);
    }
    /**
     * Attempts to create a session of a certain type.
     *
     * @private
     *
     * @param {string} type The desired type to create.
     * @returns {Promise}
     */
    _createSession(type) {
        return __awaiter(this, void 0, void 0, function* () {
            const session = this.database.session();
            const labels = this.options.labels;
            this._inventory.borrowed.add(session);
            const createSession = () => __awaiter(this, void 0, void 0, function* () {
                yield session.create({ labels });
                if (type === "readwrite" /* ReadWrite */) {
                    try {
                        yield this._prepareTransaction(session);
                    }
                    catch (e) {
                        type = "readonly" /* ReadOnly */;
                    }
                }
            });
            try {
                yield this._requests.add(createSession);
            }
            catch (e) {
                this._inventory.borrowed.delete(session);
                throw e;
            }
            session.type = type;
            session.lastUsed = Date.now();
            this._inventory[type].push(session);
            this._inventory.borrowed.delete(session);
        });
    }
    /**
     * Attempts to create a session but emits any errors that occur.
     *
     * @private
     *
     * @emits SessionPool#available
     * @emits SessionPool#error
     * @param {string} type The desired type to create.
     * @returns {Promise}
     */
    _createSessionInBackground(type) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._createSession(type);
                this.emit('available');
            }
            catch (e) {
                this.emit('error', e);
            }
        });
    }
    /**
     * Attempts to delete a session, optionally creating a new one of the same
     * type if the pool is still open and we're under the configured min value.
     *
     * @private
     *
     * @fires SessoinPool#error
     * @param {Session} session The session to delete.
     * @returns {Promise}
     */
    _destroy(session) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._requests.add(() => session.delete());
            }
            catch (e) {
                this.emit('error', e);
            }
        });
    }
    /**
     * Deletes idle sessions that exceed the maxIdle configuration.
     *
     * @private
     */
    _evictIdleSessions() {
        const { maxIdle, min } = this.options;
        const size = this.size;
        const idle = this._getIdleSessions();
        let count = idle.length;
        let evicted = 0;
        while (count-- > maxIdle && size - evicted++ > min) {
            const session = idle.pop();
            if (!session) {
                continue;
            }
            const type = session.type;
            const index = this._inventory[type].indexOf(session);
            this._inventory[type].splice(index, 1);
            this._destroy(session);
        }
    }
    /**
     * Fills the pool with the minimum number of sessions.
     *
     * @return {Promise}
     */
    _fill() {
        return __awaiter(this, void 0, void 0, function* () {
            const requests = [];
            const minReadWrite = Math.floor(this.options.min * this.options.writes);
            const neededReadWrite = Math.max(minReadWrite - this.writes, 0);
            for (let i = 0; i < neededReadWrite; i++) {
                requests.push(this._createSessionInBackground("readwrite" /* ReadWrite */));
            }
            const minReadOnly = Math.ceil(this.options.min - minReadWrite);
            const neededReadOnly = Math.max(minReadOnly - this.reads, 0);
            for (let i = 0; i < neededReadOnly; i++) {
                requests.push(this._createSessionInBackground("readonly" /* ReadOnly */));
            }
            yield Promise.all(requests);
        });
    }
    /**
     * Retrieves a list of all the idle sessions.
     *
     * @private
     *
     * @returns {Session[]}
     */
    _getIdleSessions() {
        const idlesAfter = this.options.idlesAfter * 60000;
        const sessions = [
            ...this._inventory["readonly" /* ReadOnly */], ...this._inventory["readwrite" /* ReadWrite */]
        ];
        return sessions.filter(session => {
            return Date.now() - session.lastUsed >= idlesAfter;
        });
    }
    /**
     * Returns stack traces for sessions that have not been released.
     *
     * @return {string[]}
     */
    _getLeaks() {
        return [...this._traces.values()].map(SessionPool.formatTrace);
    }
    /**
     * Attempts to get a session of a specific type. If the type is unavailable it
     * may try to use a different type.
     *
     * @private
     *
     * @param {string} type The desired session type.
     * @param {number} startTime Timestamp to use when determining timeouts.
     * @returns {Promise<Session>}
     */
    _getSession(type, startTime) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.available) {
                return this._borrowNextAvailableSession(type);
            }
            if (this.options.fail) {
                throw new Error('No resources available.');
            }
            let removeListener;
            const promises = [
                this._onClose.then(() => {
                    throw new Error("Database is closed." /* Closed */);
                }),
                new Promise(resolve => {
                    this.once('available', resolve);
                    removeListener = this.removeListener.bind(this, 'available', resolve);
                }),
            ];
            const timeout = this.options.acquireTimeout;
            if (!is.infinite(timeout)) {
                const elapsed = Date.now() - startTime;
                const remaining = timeout - elapsed;
                promises.push(new Promise((_, reject) => {
                    const error = new Error("Timeout occurred while acquiring session." /* Timeout */);
                    setTimeout(reject.bind(null, error), remaining);
                }));
            }
            if (!this.isFull) {
                promises.push(new Promise((resolve, reject) => {
                    this._createSession(type).then(() => this.emit('available'), reject);
                }));
            }
            try {
                yield Promise.race(promises);
            }
            catch (e) {
                removeListener();
                throw e;
            }
            return this._borrowNextAvailableSession(type);
        });
    }
    /**
     * Checks to see whether or not session is expired.
     *
     * @param {Session} session The session to check.
     * @returns {boolean}
     */
    _isValidSession(session) {
        // unpinged sessions only stay good for 1 hour
        const MAX_DURATION = 60000 * 60;
        return Date.now() - session.lastUsed < MAX_DURATION;
    }
    /**
     * Pings an individual session.
     *
     * @private
     *
     * @param {Session} session The session to ping.
     * @returns {Promise}
     */
    _ping(session) {
        return __awaiter(this, void 0, void 0, function* () {
            this._borrow(session);
            if (!this._isValidSession(session)) {
                this._inventory.borrowed.delete(session);
                return;
            }
            try {
                yield session.keepAlive();
                this.release(session);
            }
            catch (e) {
                this._inventory.borrowed.delete(session);
                this._destroy(session);
            }
        });
    }
    /**
     * Makes a keep alive request to all the idle sessions.
     *
     * @private
     *
     * @returns {Promise}
     */
    _pingIdleSessions() {
        return __awaiter(this, void 0, void 0, function* () {
            const sessions = this._getIdleSessions();
            const pings = sessions.map(session => this._ping(session));
            yield Promise.all(pings);
            return this._fill();
        });
    }
    /**
     * Creates a transaction for a session.
     *
     * @private
     *
     * @param {Session} session The session object.
     * @param {object} options The transaction options.
     * @returns {Promise}
     */
    _prepareTransaction(session) {
        return __awaiter(this, void 0, void 0, function* () {
            const transaction = session.transaction();
            yield transaction.begin();
            session.txn = transaction;
        });
    }
    /**
     * Releases a session back into the pool.
     *
     * @private
     *
     * @fires SessionPool#available
     * @param {Session} session The session object.
     */
    _release(session) {
        const type = session.type;
        this._inventory[type].unshift(session);
        this._inventory.borrowed.delete(session);
        this._traces.delete(session.id);
        this.emit('available');
    }
    /**
     * Starts housekeeping (pinging/evicting) of idle sessions.
     *
     * @private
     */
    _startHouseKeeping() {
        const evictRate = this.options.idlesAfter * 60000;
        this._evictHandle = setInterval(() => this._evictIdleSessions(), evictRate);
        this._evictHandle.unref();
        const pingRate = this.options.keepAlive * 60000;
        this._pingHandle = setInterval(() => this._pingIdleSessions(), pingRate);
        this._pingHandle.unref();
    }
    /**
     * Stops housekeeping.
     *
     * @private
     */
    _stopHouseKeeping() {
        clearInterval(this._pingHandle);
        clearInterval(this._evictHandle);
    }
}
exports.SessionPool = SessionPool;
//# sourceMappingURL=session-pool.js.map