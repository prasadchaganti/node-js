"use strict";
/*!
 * Copyright 2019 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const promisify_1 = require("@google-cloud/promisify");
const google_gax_1 = require("google-gax");
const grpc_1 = require("grpc");
const path_1 = require("path");
const protobufjs_1 = require("protobufjs");
const through = require("through2");
const RETRY_INFO = 'google.rpc.retryinfo-bin';
const RETRYABLE = [
    grpc_1.status.ABORTED,
    grpc_1.status.UNKNOWN,
];
// tslint:disable-next-line variable-name
const RetryInfo = protobufjs_1.loadSync(path_1.join(__dirname, '..', 'protos', 'google/rpc/error_details.proto'), new google_gax_1.GoogleProtoFilesRoot())
    .lookup('google.rpc.RetryInfo');
/**
 * Error class used to signal a Transaction timeout.
 *
 * @private
 * @class
 *
 * @param {Error} [err] The last known retryable Error.
 */
class DeadlineError extends Error {
    constructor(error) {
        super('Deadline for Transaction exceeded.');
        this.code = grpc_1.status.DEADLINE_EXCEEDED;
        this.errors = [];
        if (error) {
            this.errors.push(error);
        }
    }
}
exports.DeadlineError = DeadlineError;
/**
 * Base class for running/retrying Transactions.
 *
 * @private
 * @class
 * @abstract
 *
 * @param {Database} database The Database to pull Sessions/Transactions from.
 * @param {RunTransactionOptions} [options] The runner options.
 */
class Runner {
    constructor(session, transaction, options) {
        this.attempts = 0;
        this.session = session;
        this.transaction = transaction;
        const defaults = { timeout: 3600000 };
        this.options = Object.assign(defaults, options);
    }
    /**
     * Attempts to retrieve the retry delay from the supplied error. If absent it
     * will create one based on the number of attempts made thus far.
     *
     * @private
     *
     * @param {Error} err The service error.
     * @returns {number} Delay in milliseconds.
     */
    getNextDelay(err) {
        const retryInfo = err.metadata && err.metadata.get(RETRY_INFO);
        if (retryInfo && retryInfo.length) {
            // tslint:disable-next-line no-any
            const { retryDelay } = RetryInfo.decode(retryInfo[0]);
            let { seconds } = retryDelay;
            if (typeof seconds !== 'number') {
                seconds = seconds.toNumber();
            }
            const secondsInMs = Math.floor(seconds) * 1000;
            const nanosInMs = Math.floor(retryDelay.nanos) / 1e6;
            return secondsInMs + nanosInMs;
        }
        return Math.pow(2, this.attempts) * 1000 + Math.floor(Math.random() * 1000);
    }
    /**
     * Retrieves a transaction to run against.
     *
     * @private
     *
     * @returns Promise<Transaction>
     */
    getTransaction() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.transaction) {
                const transaction = this.transaction;
                delete this.transaction;
                return transaction;
            }
            const transaction = this.session.transaction();
            yield transaction.begin();
            return transaction;
        });
    }
    /**
     * This function is responsible for getting transactions, running them and
     * handling any errors, retrying if necessary.
     *
     * @private
     *
     * @returns {Promise}
     */
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            const start = Date.now();
            const timeout = this.options.timeout;
            let lastError;
            while (Date.now() - start < timeout) {
                const transaction = yield this.getTransaction();
                try {
                    return yield this._run(transaction);
                }
                catch (e) {
                    lastError = e;
                }
                if (!RETRYABLE.includes(lastError.code)) {
                    throw lastError;
                }
                this.attempts += 1;
                const delay = this.getNextDelay(lastError);
                yield new Promise(resolve => setTimeout(resolve, delay));
            }
            throw new DeadlineError(lastError);
        });
    }
}
exports.Runner = Runner;
/**
 * This class handles transactions expecting to be ran in callback mode.
 *
 * @private
 * @class
 *
 * @param {Database} database The database to pull sessions/transactions from.
 * @param {RunTransactionCallback} runFn The user supplied run function.
 * @param {RunTransactionOptions} [options] Runner options.
 */
class TransactionRunner extends Runner {
    constructor(session, transaction, runFn, options) {
        super(session, transaction, options);
        this.runFn = runFn;
    }
    /**
     * Because the user has decided to use callback mode, we want to try and
     * intercept any ABORTED or UNKNOWN errors and stop the current function
     * execution.
     *
     * @private
     *
     * @param {Transaction} transaction The transaction to intercept errors for.
     * @param {Function} reject Function to call when a retryable error is found.
     */
    _interceptErrors(transaction, reject) {
        const request = transaction.request;
        transaction.request = promisify_1.promisify((config, callback) => {
            request(config, (err, resp) => {
                if (!err || !RETRYABLE.includes(err.code)) {
                    callback(err, resp);
                    return;
                }
                reject(err);
            });
        });
        const requestStream = transaction.requestStream;
        transaction.requestStream = (config) => {
            const proxyStream = through.obj();
            const stream = requestStream(config);
            stream
                .on('error', (err) => {
                if (!RETRYABLE.includes(err.code)) {
                    proxyStream.destroy(err);
                    return;
                }
                stream.unpipe(proxyStream);
                reject(err);
            })
                .pipe(proxyStream);
            return proxyStream;
        };
    }
    /**
     * Creates a Promise that should resolve when the provided transaction has
     * been committed or rolled back. Rejects if a retryable error occurs.
     *
     * @private
     *
     * @param {Transaction}
     * @returns {Promise}
     */
    _run(transaction) {
        return new Promise((resolve, reject) => {
            transaction.once('end', resolve);
            this._interceptErrors(transaction, reject);
            this.runFn(null, transaction);
        });
    }
}
exports.TransactionRunner = TransactionRunner;
/**
 * This class handles transactions expecting to be ran in promise mode.
 *
 * @private
 * @class
 *
 * @param {Database} database The database to pull sessions/transactions from.
 * @param {AsyncRunTransactionCallback} runFn The user supplied run function.
 * @param {RunTransactionOptions} [options] Runner options.
 */
class AsyncTransactionRunner extends Runner {
    constructor(session, transaction, runFn, options) {
        super(session, transaction, options);
        this.runFn = runFn;
    }
    /**
     * Since this is promise mode all we need to do is return the user function.
     *
     * @private
     *
     * @param {Transaction} transaction The transaction to be ran against.
     * @returns {Promise}
     */
    _run(transaction) {
        return this.runFn(transaction);
    }
}
exports.AsyncTransactionRunner = AsyncTransactionRunner;
//# sourceMappingURL=transaction-runner.js.map