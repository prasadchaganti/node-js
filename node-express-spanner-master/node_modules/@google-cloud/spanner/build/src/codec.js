"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/*!
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const common_grpc_1 = require("@google-cloud/common-grpc");
const precise_date_1 = require("@google-cloud/precise-date");
const arrify = require("arrify");
const is = require("is");
/**
 * Date-like object used to represent Cloud Spanner Dates. DATE types represent
 * a logical calendar date, independent of time zone. DATE values do not
 * represent a specific 24-hour period. Rather, a given DATE value represents a
 * different 24-hour period when interpreted in a different time zone. Because
 * of this, all values passed to {@link Spanner.date} will be interpreted as
 * local time.
 *
 * To represent an absolute point in time, use {@link Spanner.timestamp}.
 *
 * @see Spanner.date
 * @see https://cloud.google.com/spanner/docs/data-types#date-type
 *
 * @class
 * @extends Date
 *
 * @param {string|number} [date] String representing the date or number
 *     representing the year.
 * @param {number} [month] Number representing the month.
 * @param {number} [date] Number representing the date.
 *
 * @example
 * Spanner.date('3-3-1933');
 */
class SpannerDate extends Date {
    constructor(...dateFields) {
        const yearOrDateString = dateFields[0];
        if (!yearOrDateString) {
            dateFields[0] = new Date().toDateString();
        }
        // JavaScript Date objects will interpret ISO date strings as Zulu time,
        // but by formatting it, we can infer local time.
        if (/^\d{4}-\d{1,2}-\d{1,2}/.test(yearOrDateString)) {
            const [year, month, date] = yearOrDateString.split(/-|T/);
            dateFields = [`${month}-${date}-${year}`];
        }
        super(...dateFields.slice(0, 3));
    }
    /**
     * Returns the date in ISO date format.
     * `YYYY-[M]M-[D]D`
     *
     * @returns {string}
     */
    toJSON() {
        const year = this.getFullYear();
        let month = (this.getMonth() + 1).toString();
        let date = this.getDate().toString();
        if (month.length === 1) {
            month = `0${month}`;
        }
        if (date.length === 1) {
            date = `0${date}`;
        }
        return `${year}-${month}-${date}`;
    }
}
exports.SpannerDate = SpannerDate;
/**
 * Using an abstract class to simplify checking for wrapped numbers.
 *
 * @private
 */
class WrappedNumber {
}
/**
 * @typedef Float
 * @see Spanner.float
 */
class Float extends WrappedNumber {
    constructor(value) {
        super();
        this.value = value;
    }
    valueOf() {
        return Number(this.value);
    }
}
exports.Float = Float;
/**
 * @typedef Int
 * @see Spanner.int
 */
class Int extends WrappedNumber {
    constructor(value) {
        super();
        this.value = value.toString();
    }
    valueOf() {
        const num = Number(this.value);
        if (num > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Integer ${this.value} is out of bounds.`);
        }
        return num;
    }
}
exports.Int = Int;
/**
 * @typedef Struct
 * @see Spanner.struct
 */
class Struct extends Array {
    /**
     * Converts struct into a pojo (plain old JavaScript object).
     *
     * @param {JSONOptions} [options] JSON options.
     * @returns {object}
     */
    toJSON(options) {
        return exports.codec.convertFieldsToJson(this, options);
    }
    /**
     * Converts an array of fields to a struct.
     *
     * @private
     *
     * @param {object[]} fields List of struct fields.
     * @return {Struct}
     */
    static fromArray(fields) {
        return new Struct(...fields);
    }
    /**
     * Converts a JSON object to a struct.
     *
     * @private
     *
     * @param {object} json Struct JSON.
     * @return {Struct}
     */
    static fromJSON(json) {
        const fields = Object.keys(json || {}).map(name => {
            const value = json[name];
            return { name, value };
        });
        return Struct.fromArray(fields);
    }
}
exports.Struct = Struct;
/**
 * @typedef JSONOptions
 * @property {boolean} [wrapNumbers=false] Indicates if the numbers should be
 *     wrapped in Int/Float wrappers.
 * @property {boolean} [wrapStructs=false] Indicates if the structs should be
 *     wrapped in Struct wrapper.
 */
/**
 * Wherever a row or struct object is returned, it is assigned a "toJSON"
 * function. This function will generate the JSON for that row.
 *
 * @private
 *
 * @param {array} row The row to generate JSON for.
 * @param {JSONOptions} [options] JSON options.
 * @returns {object}
 */
function convertFieldsToJson(fields, options) {
    const json = {};
    const defaultOptions = { wrapNumbers: false, wrapStructs: false };
    options = Object.assign(defaultOptions, options);
    for (const { name, value } of fields) {
        if (!name) {
            continue;
        }
        try {
            json[name] = convertValueToJson(value, options);
        }
        catch (e) {
            e.message = [
                `Serializing column "${name}" encountered an error: ${e.message}`,
                'Call row.toJSON({ wrapNumbers: true }) to receive a custom type.',
            ].join(' ');
            throw e;
        }
    }
    return json;
}
/**
 * Attempts to convert a wrapped or nested value into a native JavaScript type.
 *
 * @private
 *
 * @param {*} value The value to convert.
 * @param {JSONOptions} options JSON options.
 * @return {*}
 */
function convertValueToJson(value, options) {
    if (!options.wrapNumbers && value instanceof WrappedNumber) {
        return value.valueOf();
    }
    if (value instanceof Struct) {
        if (!options.wrapStructs) {
            return value.toJSON(options);
        }
        return value.map(({ name, value }) => {
            value = convertValueToJson(value, options);
            return { name, value };
        });
    }
    if (Array.isArray(value)) {
        return value.map(child => convertValueToJson(child, options));
    }
    return value;
}
/**
 * Re-decode after the generic gRPC decoding step.
 *
 * @private
 *
 * @param {*} value Value to decode
 * @param {object[]} type Value type object.
 * @returns {*}
 */
function decode(value, type) {
    if (is.null(value)) {
        return null;
    }
    let decoded = value;
    switch (type.code) {
        case "BYTES" /* BYTES */:
            decoded = Buffer.from(decoded, 'base64');
            break;
        case "FLOAT64" /* FLOAT64 */:
            decoded = new Float(decoded);
            break;
        case "INT64" /* INT64 */:
            decoded = new Int(decoded);
            break;
        case "TIMESTAMP" /* TIMESTAMP */:
            decoded = new precise_date_1.PreciseDate(decoded);
            break;
        case "DATE" /* DATE */:
            decoded = new SpannerDate(decoded);
            break;
        case "ARRAY" /* ARRAY */:
            decoded = decoded.map(value => {
                return decode(value, type.arrayElementType);
            });
            break;
        case "STRUCT" /* STRUCT */:
            const fields = type.structType.fields.map(({ name, type }, index) => {
                const value = decode(decoded[name] || decoded[index], type);
                return { name, value };
            });
            decoded = Struct.fromArray(fields);
            break;
        default:
            break;
    }
    return decoded;
}
/**
 * Encode a value in the format the API expects.
 *
 * @private
 *
 * @param {*} value The value to be encoded.
 * @returns {object} google.protobuf.Value
 */
function encode(value) {
    return common_grpc_1.Service.encodeValue_(encodeValue(value));
}
/**
 * Formats values into expected format of google.protobuf.Value. The actual
 * conversion to a google.protobuf.Value object happens via
 * `Service.encodeValue_`
 *
 * @private
 *
 * @param {*} value The value to be encoded.
 * @returns {*}
 */
function encodeValue(value) {
    if (is.number(value) && !is.decimal(value)) {
        return value.toString();
    }
    if (is.date(value)) {
        return value.toJSON();
    }
    if (value instanceof WrappedNumber) {
        return value.value;
    }
    if (Buffer.isBuffer(value)) {
        return value.toString('base64');
    }
    if (value instanceof Struct) {
        return Array.from(value).map(field => encodeValue(field.value));
    }
    if (is.array(value)) {
        return value.map(encodeValue);
    }
    return value;
}
/**
 * Just a map with friendlier names for the types.
 *
 * @private
 * @enum {string}
 */
var TypeCode;
(function (TypeCode) {
    TypeCode["unspecified"] = "TYPE_CODE_UNSPECIFIED";
    TypeCode["bool"] = "BOOL";
    TypeCode["int64"] = "INT64";
    TypeCode["float64"] = "FLOAT64";
    TypeCode["timestamp"] = "TIMESTAMP";
    TypeCode["date"] = "DATE";
    TypeCode["string"] = "STRING";
    TypeCode["bytes"] = "BYTES";
    TypeCode["array"] = "ARRAY";
    TypeCode["struct"] = "STRUCT";
})(TypeCode || (TypeCode = {}));
/**
 * @typedef {ParamType} StructField
 * @property {string} name The name of the field.
 */
/**
 * @typedef {object} ParamType
 * @property {string} type The param type. Must be one of the following:
 *     - float64
 *     - int64
 *     - bool
 *     - string
 *     - bytes
 *     - timestamp
 *     - date
 *     - struct
 *     - array
 * @property {StructField[]} [fields] **For struct types only**. Type
 *     definitions for the individual fields.
 * @property {string|ParamType} [child] **For array types only**. The array
 *     element type.
 */
/**
 * Get the corresponding Spanner data type for the provided value.
 *
 * @private
 *
 * @param {*} value - The value.
 * @returns {object}
 *
 * @example
 * codec.getType(NaN);
 * // {type: 'float64'}
 */
function getType(value) {
    const isSpecialNumber = is.infinite(value) ||
        (is.number(value) && isNaN(value));
    if (is.decimal(value) || isSpecialNumber || value instanceof Float) {
        return { type: 'float64' };
    }
    if (is.number(value) || value instanceof Int) {
        return { type: 'int64' };
    }
    if (is.boolean(value)) {
        return { type: 'bool' };
    }
    if (is.string(value)) {
        return { type: 'string' };
    }
    if (Buffer.isBuffer(value)) {
        return { type: 'bytes' };
    }
    if (value instanceof SpannerDate) {
        return { type: 'date' };
    }
    if (is.date(value)) {
        return { type: 'timestamp' };
    }
    if (value instanceof Struct) {
        return {
            type: 'struct',
            fields: Array.from(value).map(({ name, value }) => {
                return Object.assign({ name }, getType(value));
            }),
        };
    }
    if (is.array(value)) {
        let child;
        for (let i = 0; i < value.length; i++) {
            child = value[i];
            if (!is.null(child)) {
                break;
            }
        }
        return {
            type: 'array',
            child: getType(child),
        };
    }
    return { type: 'unspecified' };
}
/**
 * Converts a value to google.protobuf.ListValue
 *
 * @private
 *
 * @param {*} value The value to convert.
 * @returns {object}
 */
function convertToListValue(value) {
    const values = arrify(value).map(exports.codec.encode);
    return { values };
}
/**
 * Converts milliseconds to google.protobuf.Timestamp
 *
 * @private
 *
 * @param {number} ms The milliseconds to convert.
 * @returns {object}
 */
function convertMsToProtoTimestamp(ms) {
    const rawSeconds = ms / 1000;
    const seconds = Math.floor(rawSeconds);
    const nanos = Math.round((rawSeconds - seconds) * 1e9);
    return { seconds, nanos };
}
/**
 * Converts google.protobuf.Timestamp to Date object.
 *
 * @private
 *
 * @param {object} timestamp The protobuf timestamp.
 * @returns {Date}
 */
function convertProtoTimestampToDate({ nanos = 0, seconds = 0 }) {
    const ms = Math.floor(nanos) / 1e6;
    const s = Math.floor(seconds);
    return new Date(s * 1000 + ms);
}
/**
 * Encodes paramTypes into correct structure.
 *
 * @private
 *
 * @param {object|string} [config='unspecified'] Type config.
 * @return {object}
 */
function createTypeObject(friendlyType) {
    if (!friendlyType) {
        friendlyType = 'unspecified';
    }
    if (is.string(friendlyType)) {
        friendlyType = { type: friendlyType };
    }
    const config = friendlyType;
    const code = TypeCode[config.type] || TypeCode.unspecified;
    const type = { code };
    if (code === "ARRAY" /* ARRAY */) {
        type.arrayElementType = exports.codec.createTypeObject(config.child);
    }
    if (code === "STRUCT" /* STRUCT */) {
        type.structType = {
            fields: arrify(config.fields).map(field => {
                return { name: field.name, type: exports.codec.createTypeObject(field) };
            })
        };
    }
    return type;
}
exports.codec = {
    convertToListValue,
    convertMsToProtoTimestamp,
    convertProtoTimestampToDate,
    createTypeObject,
    SpannerDate,
    Float,
    Int,
    convertFieldsToJson,
    decode,
    encode,
    getType,
    Struct
};
//# sourceMappingURL=codec.js.map