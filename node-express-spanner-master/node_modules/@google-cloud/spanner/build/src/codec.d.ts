import { common as p } from 'protobufjs';
import { SpannerClient as s } from './v1';
export declare type Value = any;
export interface Field {
    name: string;
    value: Value;
}
export interface Json {
    [field: string]: Value;
}
export interface JSONOptions {
    wrapNumbers?: boolean;
    wrapStructs?: boolean;
}
/**
 * Date-like object used to represent Cloud Spanner Dates. DATE types represent
 * a logical calendar date, independent of time zone. DATE values do not
 * represent a specific 24-hour period. Rather, a given DATE value represents a
 * different 24-hour period when interpreted in a different time zone. Because
 * of this, all values passed to {@link Spanner.date} will be interpreted as
 * local time.
 *
 * To represent an absolute point in time, use {@link Spanner.timestamp}.
 *
 * @see Spanner.date
 * @see https://cloud.google.com/spanner/docs/data-types#date-type
 *
 * @class
 * @extends Date
 *
 * @param {string|number} [date] String representing the date or number
 *     representing the year.
 * @param {number} [month] Number representing the month.
 * @param {number} [date] Number representing the date.
 *
 * @example
 * Spanner.date('3-3-1933');
 */
export declare class SpannerDate extends Date {
    constructor(dateString?: string);
    constructor(year: number, month: number, date: number);
    /**
     * Returns the date in ISO date format.
     * `YYYY-[M]M-[D]D`
     *
     * @returns {string}
     */
    toJSON(): string;
}
/**
 * Using an abstract class to simplify checking for wrapped numbers.
 *
 * @private
 */
declare abstract class WrappedNumber {
    value: string | number;
    abstract valueOf(): number;
}
/**
 * @typedef Float
 * @see Spanner.float
 */
export declare class Float extends WrappedNumber {
    value: number;
    constructor(value: number);
    valueOf(): number;
}
/**
 * @typedef Int
 * @see Spanner.int
 */
export declare class Int extends WrappedNumber {
    value: string;
    constructor(value: string);
    valueOf(): number;
}
/**
 * @typedef Struct
 * @see Spanner.struct
 */
export declare class Struct extends Array<Field> {
    /**
     * Converts struct into a pojo (plain old JavaScript object).
     *
     * @param {JSONOptions} [options] JSON options.
     * @returns {object}
     */
    toJSON(options?: JSONOptions): Json;
    /**
     * Converts an array of fields to a struct.
     *
     * @private
     *
     * @param {object[]} fields List of struct fields.
     * @return {Struct}
     */
    static fromArray(fields: Field[]): Struct;
    /**
     * Converts a JSON object to a struct.
     *
     * @private
     *
     * @param {object} json Struct JSON.
     * @return {Struct}
     */
    static fromJSON(json: Json): Struct;
}
/**
 * @typedef JSONOptions
 * @property {boolean} [wrapNumbers=false] Indicates if the numbers should be
 *     wrapped in Int/Float wrappers.
 * @property {boolean} [wrapStructs=false] Indicates if the structs should be
 *     wrapped in Struct wrapper.
 */
/**
 * Wherever a row or struct object is returned, it is assigned a "toJSON"
 * function. This function will generate the JSON for that row.
 *
 * @private
 *
 * @param {array} row The row to generate JSON for.
 * @param {JSONOptions} [options] JSON options.
 * @returns {object}
 */
declare function convertFieldsToJson(fields: Field[], options?: JSONOptions): Json;
/**
 * Re-decode after the generic gRPC decoding step.
 *
 * @private
 *
 * @param {*} value Value to decode
 * @param {object[]} type Value type object.
 * @returns {*}
 */
declare function decode(value: Value, type: s.Type): Value;
/**
 * Encode a value in the format the API expects.
 *
 * @private
 *
 * @param {*} value The value to be encoded.
 * @returns {object} google.protobuf.Value
 */
declare function encode(value: Value): p.IValue;
/**
 * Conveniece Type object that simplifies specifying the data type, the array
 * child type and/or struct fields.
 *
 * @private
 */
export interface Type {
    type: string;
    fields?: FieldType[];
    child?: Type;
}
interface FieldType extends Type {
    name: string;
}
/**
 * @typedef {ParamType} StructField
 * @property {string} name The name of the field.
 */
/**
 * @typedef {object} ParamType
 * @property {string} type The param type. Must be one of the following:
 *     - float64
 *     - int64
 *     - bool
 *     - string
 *     - bytes
 *     - timestamp
 *     - date
 *     - struct
 *     - array
 * @property {StructField[]} [fields] **For struct types only**. Type
 *     definitions for the individual fields.
 * @property {string|ParamType} [child] **For array types only**. The array
 *     element type.
 */
/**
 * Get the corresponding Spanner data type for the provided value.
 *
 * @private
 *
 * @param {*} value - The value.
 * @returns {object}
 *
 * @example
 * codec.getType(NaN);
 * // {type: 'float64'}
 */
declare function getType(value: Value): Type;
/**
 * Converts a value to google.protobuf.ListValue
 *
 * @private
 *
 * @param {*} value The value to convert.
 * @returns {object}
 */
declare function convertToListValue<T>(value: T): p.IListValue;
/**
 * Converts milliseconds to google.protobuf.Timestamp
 *
 * @private
 *
 * @param {number} ms The milliseconds to convert.
 * @returns {object}
 */
declare function convertMsToProtoTimestamp(ms: number): p.ITimestamp;
/**
 * Converts google.protobuf.Timestamp to Date object.
 *
 * @private
 *
 * @param {object} timestamp The protobuf timestamp.
 * @returns {Date}
 */
declare function convertProtoTimestampToDate({ nanos, seconds }: p.ITimestamp): Date;
/**
 * Encodes paramTypes into correct structure.
 *
 * @private
 *
 * @param {object|string} [config='unspecified'] Type config.
 * @return {object}
 */
declare function createTypeObject(friendlyType?: string | Type): s.Type;
export declare const codec: {
    convertToListValue: typeof convertToListValue;
    convertMsToProtoTimestamp: typeof convertMsToProtoTimestamp;
    convertProtoTimestampToDate: typeof convertProtoTimestampToDate;
    createTypeObject: typeof createTypeObject;
    SpannerDate: typeof SpannerDate;
    Float: typeof Float;
    Int: typeof Int;
    convertFieldsToJson: typeof convertFieldsToJson;
    decode: typeof decode;
    encode: typeof encode;
    getType: typeof getType;
    Struct: typeof Struct;
};
export {};
